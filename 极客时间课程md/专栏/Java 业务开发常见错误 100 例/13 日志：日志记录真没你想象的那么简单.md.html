<!DOCTYPE html>

<!-- saved from url=(0046)https://kaiiiz.github.io/hexo-theme-book-demo/ -->

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

    <head>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

        <link rel="icon" href="/static/favicon.png">

        <title>13 日志：日志记录真没你想象的那么简单.md.html</title>

        <!-- Spectre.css framework -->

        <link rel="stylesheet" href="/static/index.css">

        <!-- theme css & js -->

        <meta name="generator" content="Hexo 4.2.0">

    </head>



<body>



<div class="book-container">

    <div class="book-sidebar">

        <div class="book-brand">

            <a href="/">

                <img src="/static/favicon.png">

                <span>技术文章摘抄</span>

            </a>

        </div>

        <div class="book-menu uncollapsible">

            <ul class="uncollapsible">

                <li><a href="/" class="current-tab">首页</a></li>

            </ul>



            <ul class="uncollapsible">

                <li><a href="../">上一级</a></li>

            </ul>



            <ul class="uncollapsible">

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/00 开篇词 业务代码真的会有这么多坑？.md.html">00 开篇词 业务代码真的会有这么多坑？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/01 使用了并发工具类库，线程安全就高枕无忧了吗？.md.html">01 使用了并发工具类库，线程安全就高枕无忧了吗？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/02 代码加锁：不要让“锁”事成为烦心事.md.html">02 代码加锁：不要让“锁”事成为烦心事.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/03 线程池：业务代码最常用也最容易犯错的组件.md.html">03 线程池：业务代码最常用也最容易犯错的组件.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/04 连接池：别让连接池帮了倒忙.md.html">04 连接池：别让连接池帮了倒忙.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/05 HTTP调用：你考虑到超时、重试、并发了吗？.md.html">05 HTTP调用：你考虑到超时、重试、并发了吗？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/06 2成的业务代码的Spring声明式事务，可能都没处理正确.md.html">06 2成的业务代码的Spring声明式事务，可能都没处理正确.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/07 数据库索引：索引并不是万能药.md.html">07 数据库索引：索引并不是万能药.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/08 判等问题：程序里如何确定你就是你？.md.html">08 判等问题：程序里如何确定你就是你？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/09 数值计算：注意精度、舍入和溢出问题.md.html">09 数值计算：注意精度、舍入和溢出问题.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/10 集合类：坑满地的List列表操作.md.html">10 集合类：坑满地的List列表操作.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/11 空值处理：分不清楚的null和恼人的空指针.md.html">11 空值处理：分不清楚的null和恼人的空指针.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/12 异常处理：别让自己在出问题的时候变为瞎子.md.html">12 异常处理：别让自己在出问题的时候变为瞎子.md.html</a>



                </li>

                <li>



                    <a class="current-tab" href="/专栏/Java 业务开发常见错误 100 例/13 日志：日志记录真没你想象的那么简单.md.html">13 日志：日志记录真没你想象的那么简单.md.html</a>

                    



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/14 文件IO：实现高效正确的文件读写并非易事.md.html">14 文件IO：实现高效正确的文件读写并非易事.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/15 序列化：一来一回你还是原来的你吗？.md.html">15 序列化：一来一回你还是原来的你吗？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/16 用好Java 8的日期时间类，少踩一些“老三样”的坑.md.html">16 用好Java 8的日期时间类，少踩一些“老三样”的坑.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/17 别以为“自动挡”就不可能出现OOM.md.html">17 别以为“自动挡”就不可能出现OOM.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/18 当反射、注解和泛型遇到OOP时，会有哪些坑？.md.html">18 当反射、注解和泛型遇到OOP时，会有哪些坑？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/19 Spring框架：IoC和AOP是扩展的核心.md.html">19 Spring框架：IoC和AOP是扩展的核心.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/20 Spring框架：框架帮我们做了很多工作也带来了复杂度.md.html">20 Spring框架：框架帮我们做了很多工作也带来了复杂度.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/21 代码重复：搞定代码重复的三个绝招.md.html">21 代码重复：搞定代码重复的三个绝招.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/22 接口设计：系统间对话的语言，一定要统一.md.html">22 接口设计：系统间对话的语言，一定要统一.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/23 缓存设计：缓存可以锦上添花也可以落井下石.md.html">23 缓存设计：缓存可以锦上添花也可以落井下石.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/24 业务代码写完，就意味着生产就绪了？.md.html">24 业务代码写完，就意味着生产就绪了？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/25 异步处理好用，但非常容易用错.md.html">25 异步处理好用，但非常容易用错.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/26 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？.md.html">26 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/27 数据源头：任何客户端的东西都不可信任.md.html">27 数据源头：任何客户端的东西都不可信任.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/28 安全兜底：涉及钱时，必须考虑防刷、限量和防重.md.html">28 安全兜底：涉及钱时，必须考虑防刷、限量和防重.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/29 数据和代码：数据就是数据，代码就是代码.md.html">29 数据和代码：数据就是数据，代码就是代码.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/30 如何正确保存和传输敏感数据？.md.html">30 如何正确保存和传输敏感数据？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/31 加餐1：带你吃透课程中Java 8的那些重要知识点（一）.md.html">31 加餐1：带你吃透课程中Java 8的那些重要知识点（一）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/32 加餐2：带你吃透课程中Java 8的那些重要知识点（二）.md.html">32 加餐2：带你吃透课程中Java 8的那些重要知识点（二）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/33 加餐3：定位应用问题，排错套路很重要.md.html">33 加餐3：定位应用问题，排错套路很重要.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/34 加餐4：分析定位Java问题，一定要用好这些工具（一）.md.html">34 加餐4：分析定位Java问题，一定要用好这些工具（一）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/35 加餐5：分析定位Java问题，一定要用好这些工具（二）.md.html">35 加餐5：分析定位Java问题，一定要用好这些工具（二）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/36 加餐6：这15年来，我是如何在工作中学习技术和英语的？.md.html">36 加餐6：这15年来，我是如何在工作中学习技术和英语的？.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/37 加餐7：程序员成长28计.md.html">37 加餐7：程序员成长28计.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/38 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑.md.html">38 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/答疑篇：代码篇思考题集锦（一）.md.html">答疑篇：代码篇思考题集锦（一）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/答疑篇：代码篇思考题集锦（三）.md.html">答疑篇：代码篇思考题集锦（三）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/答疑篇：代码篇思考题集锦（二）.md.html">答疑篇：代码篇思考题集锦（二）.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/答疑篇：加餐篇思考题答案合集.md.html">答疑篇：加餐篇思考题答案合集.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/答疑篇：安全篇思考题答案合集.md.html">答疑篇：安全篇思考题答案合集.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/答疑篇：设计篇思考题答案合集.md.html">答疑篇：设计篇思考题答案合集.md.html</a>



                </li>

                <li>



                    

                    <a href="/专栏/Java 业务开发常见错误 100 例/结束语 写代码时，如何才能尽量避免踩坑？.md.html">结束语 写代码时，如何才能尽量避免踩坑？.md.html</a>



                </li>

            </ul>



        </div>

    </div>



    <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">

        <div class="sidebar-toggle-inner"></div>

    </div>



    <script>

        function add_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.add('show')

        }



        function remove_inner() {

            let inner = document.querySelector('.sidebar-toggle-inner')

            inner.classList.remove('show')

        }



        function sidebar_toggle() {

            let sidebar_toggle = document.querySelector('.sidebar-toggle')

            let sidebar = document.querySelector('.book-sidebar')

            let content = document.querySelector('.off-canvas-content')

            if (sidebar_toggle.classList.contains('extend')) { // show

                sidebar_toggle.classList.remove('extend')

                sidebar.classList.remove('hide')

                content.classList.remove('extend')

            } else { // hide

                sidebar_toggle.classList.add('extend')

                sidebar.classList.add('hide')

                content.classList.add('extend')

            }

        }





function open_sidebar() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.add('show')

    overlay.classList.add('show')

}

function hide_canvas() {

    let sidebar = document.querySelector('.book-sidebar')

    let overlay = document.querySelector('.off-canvas-overlay')

    sidebar.classList.remove('show')

    overlay.classList.remove('show')

}



    </script>



    <div class="off-canvas-content">

        <div class="columns">

            <div class="column col-12 col-lg-12">

                <div class="book-navbar">

                    <!-- For Responsive Layout -->

                    <header class="navbar">

                        <section class="navbar-section">

                            <a onclick="open_sidebar()">

                                <i class="icon icon-menu"></i>

                            </a>

                        </section>

                    </header>

                </div>

                <div class="book-content" style="max-width: 960px; margin: 0 auto;

    overflow-x: auto;

    overflow-y: hidden;">

                    <div class="book-post">

                        <p id="tip" align="center"></p>

                        <div><h1>13 日志：日志记录真没你想象的那么简单</h1>

<p>你好，我是朱晔。今天，我和你分享的是，记录日志可能会踩的坑。</p>

<p>一些同学可能要说了，记录日志还不简单，无非是几个常用的 API 方法，比如 debug、info、warn、error；但我就见过不少坑都是记录日志引起的，容易出错主要在于三个方面：</p>

<p>日志框架众多，不同的类库可能会使用不同的日志框架，如何兼容是一个问题。</p>

<p>配置复杂且容易出错。日志配置文件通常很复杂，因此有些开发同学会从其他项目或者网络上复制一份配置文件，但却不知道如何修改，甚至是胡乱修改，造成很多问题。比如，重复记录日志的问题、同步日志的性能问题、异步记录的错误配置问题。</p>

<p>日志记录本身就有些误区，比如没考虑到日志内容获取的代价、胡乱使用日志级别等。</p>

<p>Logback、Log4j、Log4j2、commons-logging、JDK 自带的 java.util.logging 等，都是 Java 体系的日志框架，确实非常多。而不同的类库，还可能选择使用不同的日志框架。这样一来，日志的统一管理就变得非常困难。为了解决这个问题，就有了 SLF4J（Simple Logging Facade For Java），如下图所示：</p>

<p><img src="assets/97fcd8b55e5288c0e9954f070f1008fe.png" alt="img" /></p>

<p>SLF4J 实现了三种功能：</p>

<p>一是提供了统一的日志门面 API，即图中紫色部分，实现了中立的日志记录 API。</p>

<p>二是桥接功能，即图中蓝色部分，用来把各种日志框架的 API（图中绿色部分）桥接到 SLF4J API。这样一来，即便你的程序中使用了各种日志 API 记录日志，最终都可以桥接到 SLF4J 门面 API。</p>

<p>三是适配功能，即图中红色部分，可以实现 SLF4J API 和实际日志框架（图中灰色部分）的绑定。SLF4J 只是日志标准，我们还是需要一个实际的日志框架。日志框架本身没有实现 SLF4J API，所以需要有一个前置转换。Logback 就是按照 SLF4J API 标准实现的，因此不需要绑定模块做转换。</p>

<p>需要理清楚的是，虽然我们可以使用 log4j-over-slf4j 来实现 Log4j 桥接到 SLF4J，也可以使用 slf4j-log4j12 实现 SLF4J 适配到 Log4j，也把它们画到了一列，但是它不能同时使用它们，否则就会产生死循环。jcl 和 jul 也是同样的道理。</p>

<p>虽然图中有 4 个灰色的日志实现框架，但我看到的业务系统使用最广泛的是 Logback 和 Log4j，它们是同一人开发的。Logback 可以认为是 Log4j 的改进版本，我更推荐使用。所以，关于日志框架配置的案例，我都会围绕 Logback 展开。</p>

<p>Spring Boot 是目前最流行的 Java 框架，它的日志框架也用的是 Logback。那，为什么我们没有手动引入 Logback 的包，就可以直接使用 Logback 了呢？</p>

<p>查看 Spring Boot 的 Maven 依赖树，可以发现 spring-boot-starter 模块依赖了 spring-boot-starter-logging 模块，而 spring-boot-starter-logging 模块又帮我们自动引入了 logback-classic（包含了 SLF4J 和 Logback 日志框架）和 SLF4J 的一些适配器。其中，log4j-to-slf4j 用于实现 Log4j2 API 到 SLF4J 的桥接，jul-to-slf4j 则是实现 java.util.logging API 到 SLF4J 的桥接：</p>

<p><img src="assets/4c44672d280b8a30be777b78de6014e6.png" alt="img" /></p>

<p>接下来，我就用几个实际的案例和你说说日志配置和记录这两大问题，顺便以 Logback 为例复习一下常见的日志配置。</p>

<h2>为什么我的日志会重复记录？</h2>

<p>日志重复记录在业务上非常常见，不但给查看日志和统计工作带来不必要的麻烦，还会增加磁盘和日志收集系统的负担。接下来，我和你分享两个重复记录的案例，同时帮助你梳理 Logback 配置的基本结构。</p>

<p>第一个案例是，logger 配置继承关系导致日志重复记录。首先，定义一个方法实现 debug、info、warn 和 error 四种日志的记录：</p>

<pre><code>@Log4j2



@RequestMapping(&quot;logging&quot;)



@RestController



public class LoggingController {



    @GetMapping(&quot;log&quot;)



    public void log() {



        log.debug(&quot;debug&quot;);



        log.info(&quot;info&quot;);



        log.warn(&quot;warn&quot;);



        log.error(&quot;error&quot;);



    }



}

</code></pre>

<p>然后，使用下面的 Logback 配置：</p>

<p>第 11 和 12 行设置了全局的日志级别为 INFO，日志输出使用 CONSOLE Appender。</p>

<p>第 3 到 7 行，首先将 CONSOLE Appender 定义为 ConsoleAppender，也就是把日志输出到控制台（System.out/System.err）；然后通过 PatternLayout 定义了日志的输出格式。关于格式化字符串的各种使用方式，你可以进一步查阅官方文档。</p>

<p>第 8 到 10 行实现了一个 Logger 配置，将应用包的日志级别设置为 DEBUG、日志输出同样使用 CONSOLE Appender。</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;



&lt;configuration&gt;



    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;



        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;



            &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



        &lt;/layout&gt;



    &lt;/appender&gt;



    &lt;logger name=&quot;org.geekbang.time.commonmistakes.logging&quot; level=&quot;DEBUG&quot;&gt;



        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;



    &lt;/logger&gt;



    &lt;root level=&quot;INFO&quot;&gt;



        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;



    &lt;/root&gt;



&lt;/configuration&gt;



</code></pre>

<p>这段配置看起来没啥问题，但执行方法后出现了日志重复记录的问题：</p>

<p><img src="assets/2c6f45bbbe06c1ed26b514e7ac873b15.png" alt="img" /></p>

<p>从配置文件的第 9 和 12 行可以看到，CONSOLE 这个 Appender 同时挂载到了两个 Logger 上，一个是我们定义的 <logger>，一个是 <root>，由于我们定义的 <logger> 继承自 <root>，所以同一条日志既会通过 logger 记录，也会发送到 root 记录，因此应用 package 下的日志出现了重复记录。</p>

<p>后来我了解到，这个同学如此配置的初衷是实现自定义的 logger 配置，让应用内的日志暂时开启 DEBUG 级别的日志记录。其实，他完全不需要重复挂载 Appender，去掉 <logger> 下挂载的 Appender 即可：</p>

<pre><code>&lt;logger name=&quot;org.geekbang.time.commonmistakes.logging&quot; level=&quot;DEBUG&quot;/&gt;



</code></pre>

<p>如果自定义的 <logger> 需要把日志输出到不同的 Appender，比如将应用的日志输出到文件 app.log、把其他框架的日志输出到控制台，可以设置 <logger> 的 additivity 属性为 false，这样就不会继承 <root> 的 Appender 了：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;



&lt;configuration&gt;



    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;



        &lt;file&gt;app.log&lt;/file&gt;



        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;



            &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



        &lt;/encoder&gt;



    &lt;/appender&gt;



    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;



      &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;



            &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



      &lt;/layout&gt;



   &lt;/appender&gt;



    &lt;logger name=&quot;org.geekbang.time.commonmistakes.logging&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;



        &lt;appender-ref ref=&quot;FILE&quot;/&gt;



    &lt;/logger&gt;



   &lt;root level=&quot;INFO&quot;&gt;



      &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;



   &lt;/root&gt;



&lt;/configuration&gt;



</code></pre>

<p>第二个案例是，错误配置 LevelFilter 造成日志重复记录。</p>

<p>一般互联网公司都会使用 ELK 三件套来统一收集日志，有一次我们发现 Kibana 上展示的日志有部分重复，一直怀疑是 Logstash 配置错误，但最后发现还是 Logback 的配置错误引起的。</p>

<p>这个项目的日志是这样配置的：在记录日志到控制台的同时，把日志记录按照不同的级别记录到两个文件中：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;



&lt;configuration&gt;



   &lt;property name=&quot;logDir&quot; value=&quot;./logs&quot; /&gt;



   &lt;property name=&quot;app.name&quot; value=&quot;common-mistakes&quot; /&gt;



   &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;



      &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;



         &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



      &lt;/layout&gt;



   &lt;/appender&gt;



   &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;



      &lt;File&gt;${logDir}/${app.name}_info.log&lt;/File&gt;



      &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;



         &lt;level&gt;INFO&lt;/level&gt;



      &lt;/filter&gt;



      &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;



         &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



         &lt;charset&gt;UTF-8&lt;/charset&gt;



      &lt;/encoder&gt;



   &lt;/appender&gt;



   &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;



      &lt;File&gt;${logDir}/${app.name}_error.log&lt;/File&gt;



      &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;



         &lt;level&gt;WARN&lt;/level&gt;



      &lt;/filter&gt;



      &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;



         &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



         &lt;charset&gt;UTF-8&lt;/charset&gt;



      &lt;/encoder&gt;



   &lt;/appender&gt;



   &lt;root level=&quot;INFO&quot;&gt;



      &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;



      &lt;appender-ref ref=&quot;INFO_FILE&quot;/&gt;



      &lt;appender-ref ref=&quot;ERROR_FILE&quot;/&gt;



   &lt;/root&gt;



&lt;/configuration&gt;



</code></pre>

<p>这个配置文件比较长，我带着你一段一段地看：</p>

<p>第 31 到 35 行定义的 root 引用了三个 Appender。</p>

<p>第 5 到 9 行是第一个 ConsoleAppender，用于把所有日志输出到控制台。</p>

<p>第 10 到 19 行定义了一个 FileAppender，用于记录文件日志，并定义了文件名、记录日志的格式和编码等信息。最关键的是，第 12 到 14 行定义的 LevelFilter 过滤日志，将过滤级别设置为 INFO，目的是希望 _info.log 文件中可以记录 INFO 级别的日志。</p>

<p>第 20 到 30 行定义了一个类似的 FileAppender，并使用 ThresholdFilter 来过滤日志，过滤级别设置为 WARN，目的是把 WARN 以上级别的日志记录到另一个 _error.log 文件中。</p>

<p>运行一下测试程序：</p>

<p><img src="assets/e940f1310e70b65ff716dc81c9901d4e.png" alt="img" /></p>

<p>可以看到，_info.log 中包含了 INFO、WARN 和 ERROR 三个级别的日志，不符合我们的预期；error.log 包含了 WARN 和 ERROR 两个级别的日志。因此，造成了日志的重复收集。</p>

<p>你可能会问，这么明显的日志重复为什么没有及时发现？一些公司使用自动化的 ELK 方案收集日志，日志会同时输出到控制台和文件，开发人员在本机测试时不太会关心文件中记录的日志，而在测试和生产环境又因为开发人员没有服务器访问权限，所以原始日志文件中的重复问题并不容易发现。</p>

<p>为了分析日志重复的原因，我们来复习一下 ThresholdFilter 和 LevelFilter 的配置方式。</p>

<p>分析 ThresholdFilter 的源码发现，当日志级别大于等于配置的级别时返回 NEUTRAL，继续调用过滤器链上的下一个过滤器；否则，返回 DENY 直接拒绝记录日志：</p>

<pre><code>public class ThresholdFilter extends Filter&lt;ILoggingEvent&gt; {



    public FilterReply decide(ILoggingEvent event) {



        if (!isStarted()) {



            return FilterReply.NEUTRAL;



        }



    



        if (event.getLevel().isGreaterOrEqual(level)) {



            return FilterReply.NEUTRAL;



        } else {



            return FilterReply.DENY;



        }



    }



}



</code></pre>

<p>在这个案例中，把 ThresholdFilter 设置为 WARN，可以记录 WARN 和 ERROR 级别的日志。</p>

<p>LevelFilter 用来比较日志级别，然后进行相应处理：如果匹配就调用 onMatch 定义的处理方式，默认是交给下一个过滤器处理（AbstractMatcherFilter 基类中定义的默认值）；否则，调用 onMismatch 定义的处理方式，默认也是交给下一个过滤器处理。</p>

<pre><code>public class LevelFilter extends AbstractMatcherFilter&lt;ILoggingEvent&gt; {



  public FilterReply decide(ILoggingEvent event) {



      if (!isStarted()) {



          return FilterReply.NEUTRAL;



      }







      if (event.getLevel().equals(level)) {



          return onMatch;



      } else {



          return onMismatch;



      }



  }



}



public abstract class AbstractMatcherFilter&lt;E&gt; extends Filter&lt;E&gt; {



    protected FilterReply onMatch = FilterReply.NEUTRAL;



    protected FilterReply onMismatch = FilterReply.NEUTRAL;



}



</code></pre>

<p>和 ThresholdFilter 不同的是，LevelFilter 仅仅配置 level 是无法真正起作用的。由于没有配置 onMatch 和 onMismatch 属性，所以相当于这个过滤器是无用的，导致 INFO 以上级别的日志都记录了。</p>

<p>定位到问题后，修改方式就很明显了：配置 LevelFilter 的 onMatch 属性为 ACCEPT，表示接收 INFO 级别的日志；配置 onMismatch 属性为 DENY，表示除了 INFO 级别都不记录：</p>

<pre><code>&lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;



  &lt;File&gt;${logDir}/${app.name}_info.log&lt;/File&gt;



  &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;



    &lt;level&gt;INFO&lt;/level&gt;



    &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;



    &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;



  &lt;/filter&gt;



  ...



&lt;/appender&gt;



</code></pre>

<p>这样修改后，_info.log 文件中只会有 INFO 级别的日志，不会出现日志重复的问题了。</p>

<h2>使用异步日志改善性能的坑</h2>

<p>掌握了把日志输出到文件中的方法后，我们接下来面临的问题是，如何避免日志记录成为应用的性能瓶颈。这可以帮助我们解决，磁盘（比如机械磁盘）IO 性能较差、日志量又很大的情况下，如何记录日志的问题。</p>

<p>我们先来测试一下，记录日志的性能问题，定义如下的日志配置，一共有两个 Appender：</p>

<p>FILE 是一个 FileAppender，用于记录所有的日志；</p>

<p>CONSOLE 是一个 ConsoleAppender，用于记录带有 time 标记的日志。</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;



&lt;configuration&gt;



    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;



        &lt;file&gt;app.log&lt;/file&gt;



        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;



            &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



        &lt;/encoder&gt;



    &lt;/appender&gt;



    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;



        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;



            &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



        &lt;/layout&gt;



        &lt;filter class=&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;&gt;



            &lt;evaluator class=&quot;ch.qos.logback.classic.boolex.OnMarkerEvaluator&quot;&gt;



                &lt;marker&gt;time&lt;/marker&gt;



            &lt;/evaluator&gt;



            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;



            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;



        &lt;/filter&gt;



    &lt;/appender&gt;



    &lt;root level=&quot;INFO&quot;&gt;



        &lt;appender-ref ref=&quot;FILE&quot;/&gt;



        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;



    &lt;/root&gt;



&lt;/configuration&gt;



</code></pre>

<p>不知道你有没有注意到，这段代码中有个 EvaluatorFilter（求值过滤器），用于判断日志是否符合某个条件。</p>

<p>在后续的测试代码中，我们会把大量日志输出到文件中，日志文件会非常大，如果性能测试结果也混在其中的话，就很难找到那条日志。所以，这里我们使用 EvaluatorFilter 对日志按照标记进行过滤，并将过滤出的日志单独输出到控制台上。在这个案例中，我们给输出测试结果的那条日志上做了 time 标记。</p>

<p>配合使用标记和 EvaluatorFilter，实现日志的按标签过滤，是一个不错的小技巧。</p>

<p>如下测试代码中，实现了记录指定次数的大日志，每条日志包含 1MB 字节的模拟数据，最后记录一条以 time 为标记的方法执行耗时日志：</p>

<pre><code>@GetMapping(&quot;performance&quot;)



public void performance(@RequestParam(name = &quot;count&quot;, defaultValue = &quot;1000&quot;) int count) {



    long begin = System.currentTimeMillis();



    String payload = IntStream.rangeClosed(1, 1000000)



            .mapToObj(__ -&gt; &quot;a&quot;)



            .collect(Collectors.joining(&quot;&quot;)) + UUID.randomUUID().toString();



    IntStream.rangeClosed(1, count).forEach(i -&gt; log.info(&quot;{} {}&quot;, i, payload));



    Marker timeMarker = MarkerFactory.getMarker(&quot;time&quot;);



    log.info(timeMarker, &quot;took {} ms&quot;, System.currentTimeMillis() - begin);



}



</code></pre>

<p>执行程序后可以看到，记录 1000 次日志和 10000 次日志的调用耗时，分别是 6.3 秒和 44.5 秒：</p>

<p><img src="assets/7ee5152dedcbb585f23db49571bacc52.png" alt="img" /></p>

<p>对于只记录文件日志的代码了来说，这个耗时挺长的。为了分析其中原因，我们需要分析下 FileAppender 的源码。</p>

<p>FileAppender 继承自 OutputStreamAppender，查看 OutputStreamAppender 源码的第 30 到 33 行发现，在追加日志的时候，是直接把日志写入 OutputStream 中，属于同步记录日志：</p>

<pre><code>public class OutputStreamAppender&lt;E&gt; extends UnsynchronizedAppenderBase&lt;E&gt; {



  private OutputStream outputStream;



  boolean immediateFlush = true;



  @Override



    protected void append(E eventObject) {



        if (!isStarted()) {



            return;



        }



        subAppend(eventObject);



    }



    protected void subAppend(E event) {



        if (!isStarted()) {



            return;



        }



        try {



            //编码LoggingEvent



            byte[] byteArray = this.encoder.encode(event);



            //写字节流



            writeBytes(byteArray);



        } catch (IOException ioe) {



            ...



        }



    }



    private void writeBytes(byte[] byteArray) throws IOException {



        if(byteArray == null || byteArray.length == 0)



            return;



        



        lock.lock();



        try {



            //这个OutputStream其实是一个ResilientFileOutputStream，其内部使用的是带缓冲的BufferedOutputStream



            this.outputStream.write(byteArray);



            if (immediateFlush) {



                this.outputStream.flush();//刷入OS



            }



        } finally {



            lock.unlock();



        }



    }



}



</code></pre>

<p>分析到这里，我们就明白为什么日志大量写入时会耗时这么久了。那，有没有办法实现大量日志写入时，不会过多影响业务逻辑执行耗时，影响吞吐量呢？</p>

<p>办法当然有了，使用 Logback 提供的 AsyncAppender 即可实现异步的日志记录。AsyncAppende 类似装饰模式，也就是在不改变类原有基本功能的情况下为其增添新功能。这样，我们就可以把 AsyncAppender 附加在其他的 Appender 上，将其变为异步的。</p>

<p>定义一个异步 Appender ASYNCFILE，包装之前的同步文件日志记录的 FileAppender，就可以实现异步记录日志到文件：</p>

<pre><code>&lt;appender name=&quot;ASYNCFILE&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;



    &lt;appender-ref ref=&quot;FILE&quot;/&gt;



&lt;/appender&gt;



&lt;root level=&quot;INFO&quot;&gt;



    &lt;appender-ref ref=&quot;ASYNCFILE&quot;/&gt;



    &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;



&lt;/root&gt;



</code></pre>

<p>测试一下可以发现，记录 1000 次日志和 10000 次日志的调用耗时，分别是 735 毫秒和 668 毫秒：</p>

<p><img src="assets/98d1633d83734f9b8f08c3334b403ce1.png" alt="img" /></p>

<p>性能居然这么好，你觉得其中有什么问题吗？异步日志真的如此神奇和万能吗？当然不是，因为这样并没有记录下所有日志。我之前就遇到过很多关于 AsyncAppender 异步日志的坑，这些坑可以归结为三类：</p>

<p>记录异步日志撑爆内存；</p>

<p>记录异步日志出现日志丢失；</p>

<p>记录异步日志出现阻塞。</p>

<p>为了解释这三种坑，我来模拟一个慢日志记录场景：首先，自定义一个继承自 ConsoleAppender 的 MySlowAppender，作为记录到控制台的输出器，写入日志时休眠 1 秒。</p>

<pre><code>public class MySlowAppender extends ConsoleAppender {



    @Override



    protected void subAppend(Object event) {



        try {



            // 模拟慢日志



            TimeUnit.MILLISECONDS.sleep(1);



        } catch (InterruptedException e) {



            e.printStackTrace();



        }



        super.subAppend(event);



    }



}



</code></pre>

<p>然后，在配置文件中使用 AsyncAppender，将 MySlowAppender 包装为异步日志记录：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;



&lt;configuration&gt;



&lt;appender name=&quot;CONSOLE&quot; class=&quot;org.geekbang.time.commonmistakes.logging.async.MySlowAppender&quot;&gt;



    &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;



            &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%thread] [%-5level] [%logger{40}:%line] - %msg%n&lt;/pattern&gt;



    &lt;/layout&gt;



  &lt;/appender&gt;



  &lt;appender name=&quot;ASYNC&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;



    &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;



  &lt;/appender&gt;



  &lt;root level=&quot;INFO&quot;&gt;



    &lt;appender-ref ref=&quot;ASYNC&quot; /&gt;



  &lt;/root&gt;



&lt;/configuration&gt;



</code></pre>

<p>定义一段测试代码，循环记录一定次数的日志，最后输出方法执行耗时：</p>

<pre><code>@GetMapping(&quot;manylog&quot;)



public void manylog(@RequestParam(name = &quot;count&quot;, defaultValue = &quot;1000&quot;) int count) {



    long begin = System.currentTimeMillis();



    IntStream.rangeClosed(1, count).forEach(i -&gt; log.info(&quot;log-{}&quot;, i));



    System.out.println(&quot;took &quot; + (System.currentTimeMillis() - begin) + &quot; ms&quot;);



}



</code></pre>

<p>执行方法后发现，耗时很短但出现了日志丢失：我们要记录 1000 条日志，最终控制台只能搜索到 215 条日志，而且日志的行号变为了一个问号。</p>

<p><img src="assets/5fe1562b437b8672e4b1e9e463a24570.png" alt="img" /></p>

<p>出现这个问题的原因在于，AsyncAppender 提供了一些配置参数，而我们没用对。我们结合相关源码分析一下：</p>

<p>includeCallerData 用于控制是否收集调用方数据，默认是 false，此时方法行号、方法名等信息将不能显示（源码第 2 行以及 7 到 11 行）。</p>

<p>queueSize 用于控制阻塞队列大小，使用的 ArrayBlockingQueue 阻塞队列（源码第 15 到 17 行），默认大小是 256，即内存中最多保存 256 条日志。</p>

<p>discardingThreshold 是控制丢弃日志的阈值，主要是防止队列满后阻塞。默认情况下，队列剩余量低于队列长度的 20%，就会丢弃 TRACE、DEBUG 和 INFO 级别的日志。（参见源码第 3 到 6 行、18 到 19 行、26 到 27 行、33 到 34 行、40 到 42 行）</p>

<p>neverBlock 用于控制队列满的时候，加入的数据是否直接丢弃，不会阻塞等待，默认是 false（源码第 44 到 68 行）。这里需要注意一下 offer 方法和 put 方法的区别，当队列满的时候 offer 方法不阻塞，而 put 方法会阻塞；neverBlock 为 true 时，使用 offer 方法。</p>

<pre><code>public class AsyncAppender extends AsyncAppenderBase&lt;ILoggingEvent&gt; {



    boolean includeCallerData = false;//是否收集调用方数据



    protected boolean isDiscardable(ILoggingEvent event) {



        Level level = event.getLevel();



        return level.toInt() &lt;= Level.INFO_INT;//丢弃&lt;=INFO级别的日志



    }



    protected void preprocess(ILoggingEvent eventObject) {



        eventObject.prepareForDeferredProcessing();



        if (includeCallerData)



            eventObject.getCallerData();



    }



}



public class AsyncAppenderBase&lt;E&gt; extends UnsynchronizedAppenderBase&lt;E&gt; implements AppenderAttachable&lt;E&gt; {



    BlockingQueue&lt;E&gt; blockingQueue;//异步日志的关键，阻塞队列



    public static final int DEFAULT_QUEUE_SIZE = 256;//默认队列大小



    int queueSize = DEFAULT_QUEUE_SIZE;



    static final int UNDEFINED = -1;



    int discardingThreshold = UNDEFINED;



    boolean neverBlock = false;//控制队列满的时候加入数据时是否直接丢弃，不会阻塞等待



    @Override



    public void start() {



         ...



        blockingQueue = new ArrayBlockingQueue&lt;E&gt;(queueSize);



        if (discardingThreshold == UNDEFINED)



            discardingThreshold = queueSize / 5;//默认丢弃阈值是队列剩余量低于队列长度的20%，参见isQueueBelowDiscardingThreshold方法



        ...



    }



    @Override



    protected void append(E eventObject) {



        if (isQueueBelowDiscardingThreshold() &amp;&amp; isDiscardable(eventObject)) { //判断是否可以丢数据



            return;



        }



        preprocess(eventObject);



        put(eventObject);



    }



    private boolean isQueueBelowDiscardingThreshold() {



        return (blockingQueue.remainingCapacity() &lt; discardingThreshold);



    }



    private void put(E eventObject) {



        if (neverBlock) { //根据neverBlock决定使用不阻塞的offer还是阻塞的put方法



            blockingQueue.offer(eventObject);



        } else {



            putUninterruptibly(eventObject);



        }



    }



    //以阻塞方式添加数据到队列



    private void putUninterruptibly(E eventObject) {



        boolean interrupted = false;



        try {



            while (true) {



                try {



                    blockingQueue.put(eventObject);



                    break;



                } catch (InterruptedException e) {



                    interrupted = true;



                }



            }



        } finally {



            if (interrupted) {



                Thread.currentThread().interrupt();



            }



        }



    }



}  



</code></pre>

<p>看到默认队列大小为 256，达到 80% 容量后开始丢弃 &lt;=INFO 级别的日志后，我们就可以理解日志中为什么只有 215 条 INFO 日志了。</p>

<p>我们可以继续分析下异步记录日志出现坑的原因。</p>

<p>queueSize 设置得特别大，就可能会导致 OOM。</p>

<p>queueSize 设置得比较小（默认值就非常小），且 discardingThreshold 设置为大于 0 的值（或者为默认值），队列剩余容量少于 discardingThreshold 的配置就会丢弃 &lt;=INFO 的日志。这里的坑点有两个。一是，因为 discardingThreshold 的存在，设置 queueSize 时容易踩坑。比如，本例中最大日志并发是 1000，即便设置 queueSize 为 1000 同样会导致日志丢失。二是，discardingThreshold 参数容易有歧义，它不是百分比，而是日志条数。对于总容量 10000 的队列，如果希望队列剩余容量少于 1000 条的时候丢弃，需要配置为 1000。</p>

<p>neverBlock 默认为 false，意味着总可能会出现阻塞。如果 discardingThreshold 为 0，那么队列满时再有日志写入就会阻塞；如果 discardingThreshold 不为 0，也只会丢弃 &lt;=INFO 级别的日志，那么出现大量错误日志时，还是会阻塞程序。</p>

<p>可以看出 queueSize、discardingThreshold 和 neverBlock 这三个参数息息相关，务必按需进行设置和取舍，到底是性能为先，还是数据不丢为先：</p>

<p>如果考虑绝对性能为先，那就设置 neverBlock 为 true，永不阻塞。</p>

<p>如果考虑绝对不丢数据为先，那就设置 discardingThreshold 为 0，即使是 &lt;=INFO 的级别日志也不会丢，但最好把 queueSize 设置大一点，毕竟默认的 queueSize 显然太小，太容易阻塞。</p>

<p>如果希望兼顾两者，可以丢弃不重要的日志，把 queueSize 设置大一点，再设置一个合理的 discardingThreshold。</p>

<p>以上就是日志配置最常见的两个误区了。接下来，我们再看一个日志记录本身的误区。</p>

<h2>使用日志占位符就不需要进行日志级别判断了？</h2>

<p>不知道你有没有听人说过：SLF4J 的{}占位符语法，到真正记录日志时才会获取实际参数，因此解决了日志数据获取的性能问题。你觉得，这种说法对吗？</p>

<p>为了验证这个问题，我们写一段测试代码：有一个 slowString 方法，返回结果耗时 1 秒：</p>

<pre><code>private String slowString(String s) {



    System.out.println(&quot;slowString called via &quot; + s);



    try {



        TimeUnit.SECONDS.sleep(1);



    } catch (InterruptedException e) {



    }



    return &quot;OK&quot;;



}



</code></pre>

<p>如果我们记录 DEBUG 日志，并设置只记录 &gt;=INFO 级别的日志，程序是否也会耗时 1 秒呢？我们使用三种方法来测试：</p>

<p>拼接字符串方式记录 slowString；</p>

<p>使用占位符方式记录 slowString；</p>

<p>先判断日志级别是否启用 DEBUG。</p>

<pre><code>StopWatch stopWatch = new StopWatch();



stopWatch.start(&quot;debug1&quot;);



log.debug(&quot;debug1:&quot; + slowString(&quot;debug1&quot;));



stopWatch.stop();



stopWatch.start(&quot;debug2&quot;);



log.debug(&quot;debug2:{}&quot;, slowString(&quot;debug2&quot;));



stopWatch.stop();



stopWatch.start(&quot;debug3&quot;);



if (log.isDebugEnabled())



    log.debug(&quot;debug3:{}&quot;, slowString(&quot;debug3&quot;));



stopWatch.stop();



</code></pre>

<p>可以看到，前两种方式都调用了 slowString 方法，所以耗时都是 1 秒：</p>

<p><img src="assets/fbaac87cad19b2136e6f9f99bbc43183.png" alt="img" /></p>

<p>使用占位符方式记录 slowString 的方式，同样需要耗时 1 秒，是因为这种方式虽然允许我们传入 Object，不用拼接字符串，但也只是延迟（如果日志不记录那么就是省去）了日志参数对象.toString() 和字符串拼接的耗时。</p>

<p>在这个案例中，除非事先判断日志级别，否则必然会调用 slowString 方法。回到之前提的问题，使用{}占位符语法不能通过延迟参数值获取，来解决日志数据获取的性能问题。</p>

<p>除了事先判断日志级别，我们还可以通过 lambda 表达式进行延迟参数内容获取。但，SLF4J 的 API 还不支持 lambda，因此需要使用 Log4j2 日志 API，把 Lombok 的 @Slf4j 注解替换为 @Log4j2 注解，这样就可以提供一个 lambda 表达式作为提供参数数据的方法：</p>

<pre><code>@Log4j2



public class LoggingController {



...



log.debug(&quot;debug4:{}&quot;, ()-&gt;slowString(&quot;debug4&quot;));



</code></pre>

<p>像这样调用 debug 方法，签名是 Supplier&lt;?&gt;，参数会延迟到真正需要记录日志时再获取：</p>

<pre><code>void debug(String message, Supplier&lt;?&gt;... paramSuppliers);



public void logIfEnabled(final String fqcn, final Level level, final Marker marker, final String message,



        final Supplier&lt;?&gt;... paramSuppliers) {



    if (isEnabled(level, marker, message)) {



        logMessage(fqcn, level, marker, message, paramSuppliers);



    }



}



protected void logMessage(final String fqcn, final Level level, final Marker marker, final String message,



        final Supplier&lt;?&gt;... paramSuppliers) {



    final Message msg = messageFactory.newMessage(message, LambdaUtil.getAll(paramSuppliers));



    logMessageSafely(fqcn, level, marker, msg, msg.getThrowable());



}



</code></pre>

<p>修改后再次运行测试，可以看到这次 debug4 并不会调用 slowString 方法：</p>

<p><img src="assets/6c44d97b24fa51ec249759cb62828aab.png" alt="img" /></p>

<p>其实，我们只是换成了 Log4j2 API，真正的日志记录还是走的 Logback 框架。没错，这就是 SLF4J 适配的一个好处。</p>

<h2>重点回顾</h2>

<p>我将记录日志的坑，总结为框架使用配置和记录本身两个方面。</p>

<p>Java 的日志框架众多，SLF4J 实现了这些框架记录日志的统一。在使用 SLF4J 时，我们需要理清楚其桥接 API 和绑定这两个模块。如果程序启动时出现 SLF4J 的错误提示，那很可能是配置出现了问题，可以使用 Maven 的 dependency:tree 命令梳理依赖关系。</p>

<p>Logback 是 Java 最常用的日志框架，其配置比较复杂，你可以参考官方文档中关于 Appender、Layout、Filter 的配置，切记不要随意从其他地方复制别人的配置，避免出现错误或与当前需求不符。</p>

<p>使用异步日志解决性能问题，是用空间换时间。但空间毕竟有限，当空间满了之后，我们要考虑是阻塞等待，还是丢弃日志。如果更希望不丢弃重要日志，那么选择阻塞等待；如果更希望程序不要因为日志记录而阻塞，那么就需要丢弃日志。</p>

<p>最后，我强调的是，日志框架提供的参数化日志记录方式不能完全取代日志级别的判断。如果你的日志量很大，获取日志参数代价也很大，就要进行相应日志级别的判断，避免不记录日志也要花费时间获取日志参数的问题。</p>

<p>今天用到的代码，我都放在了 GitHub 上，你可以点击这个链接查看。</p>

<h2>思考与讨论</h2>

<p>在第一小节的案例中，我们把 INFO 级别的日志存放到 _info.log 中，把 WARN 和 ERROR 级别的日志存放到 _error.log 中。如果现在要把 INFO 和 WARN 级别的日志存放到 _info.log 中，把 ERROR 日志存放到 _error.log 中，应该如何配置 Logback 呢？</p>

<p>生产级项目的文件日志肯定需要按时间和日期进行分割和归档处理，以避免单个文件太大，同时保留一定天数的历史日志，你知道如何配置吗？可以在官方文档找到答案。</p>

<p>针对日志记录和配置，你还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>

</div>

                    </div>

                    <div>

                        <div style="float: left">

                            <a href="/专栏/Java 业务开发常见错误 100 例/12 异常处理：别让自己在出问题的时候变为瞎子.md.html">上一页</a>

                        </div>

                        <div style="float: right">

                            <a href="/专栏/Java 业务开发常见错误 100 例/14 文件IO：实现高效正确的文件读写并非易事.md.html">下一页</a>

                        </div>

                    </div>



                </div>

            </div>

        </div>

    </div>



    <a class="off-canvas-overlay" onclick="hide_canvas()"></a>

</div>

<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v652eace1692a40cfa3763df669d7439c1639079717194" integrity="sha512-Gi7xpJR8tSkrpF7aordPZQlW2DLtzUlZcumS8dMQjwDHEnw9I7ZLyiOj/6tZStRBGtGgN6ceN6cMH8z7etPGlw==" data-cf-beacon='{"rayId":"7099702fd90d3d60","version":"2021.12.0","r":1,"token":"1f5d475227ce4f0089a7cff1ab17c0f5","si":100}' crossorigin="anonymous"></script>

</body>

<!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>

<script>

    window.dataLayer = window.dataLayer || [];



    function gtag() {

        dataLayer.push(arguments);

    }



    gtag('js', new Date());

    gtag('config', 'G-NPSEEVD756');

    var path = window.location.pathname

    var cookie = getCookie("lastPath");

    console.log(path)

    if (path.replace("/", "") === "") {

        if (cookie.replace("/", "") !== "") {

            console.log(cookie)

            document.getElementById("tip").innerHTML = "<a href='" + cookie + "'>跳转到上次进度</a>"

        }

    } else {

        setCookie("lastPath", path)

    }



    function setCookie(cname, cvalue) {

        var d = new Date();

        d.setTime(d.getTime() + (180 * 24 * 60 * 60 * 1000));

        var expires = "expires=" + d.toGMTString();

        document.cookie = cname + "=" + cvalue + "; " + expires + ";path = /";

    }



    function getCookie(cname) {

        var name = cname + "=";

        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {

            var c = ca[i].trim();

            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);

        }

        return "";

    }



</script>



</html>

